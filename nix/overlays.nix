{ fetch ? import ./fetch.nix }:
[

  (self: super:
    { haskellPackagesGHCJS = super.haskell.packages.ghcjsHEAD; }
  )

  # Some extra sources
  (self: super:
    let
      ourOverrides =
          (super.haskell.lib.packageSourceOverrides
            { reflex-dom-contrib = fetch "reflex-dom-contrib";
            }
          );
    in
    { haskellPackages = super.haskellPackages.extend ourOverrides;
      haskellPackagesGHCJS = super.haskellPackagesGHCJS.extend ourOverrides;
    }
  )

  # Our packages
  (self: super:

    let
      ourSourceOverrides =
        super.haskell.lib.packageSourceOverrides
         (
         (self.lib.mapAttrs (k: v:
            self.lib.cleanSourceWith
              { filter = name: type:
                  # Some folders have a "test-cases" directory which we don't
                  # actually depend on during build
                  !(type == "directory" &&
                    self.lib.strings.hasSuffix "test-cases" name);
                src = self.lib.cleanSource v;
              })
         { datalake-interface = ../src/interface;
           datalake-backend = ../src/backend;
           datalake-cmdline = ../clients/cmdline;
           datalake-server = ../server;
           datalake-frontend = ../src/frontend;
         })
         );
    in
    { haskellPackages = super.haskellPackages.extend ourSourceOverrides;
      haskellPackagesGHCJS =
        super.haskellPackagesGHCJS.extend ourSourceOverrides;
    }
  )

  # Fixups for reflex and its dependencies
  (self: super:
    let
      ourOverrides =
        haskellSelf: haskellSuper:
         { exception-transformers =
             super.haskell.lib.doJailbreak
             haskellSuper.exception-transformers;

           haskell-src-exts-util = super.haskell.lib.doJailbreak
               haskellSuper.haskell-src-exts-util;

           reflex-dom-contrib = super.haskell.lib.doJailbreak
               haskellSuper.reflex-dom-contrib;

           reflex =super.haskell.lib.dontCheck
             ( haskellSuper.callPackage (import (fetch "reflex")) {});
         } // (
           let
             repo = import (fetch "reflex-dom") haskellSelf super;
             reflex-dom-core = super.haskell.lib.dontCheck
               (haskellSuper.callPackage
               ("${fetch "reflex-dom"}/reflex-dom-core") {});
             reflex-dom = haskellSuper.callPackage
               ("${fetch "reflex-dom"}/reflex-dom")
               { ghcBackend = "warp";};
           in { inherit reflex-dom reflex-dom-core ; }
         ) // (import (fetch "jsaddle") haskellSelf)
        ;
    in
    { haskellPackages = super.haskellPackages.extend ourOverrides;
      haskellPackagesGHCJS = super.haskellPackagesGHCJS.extend ourOverrides;
    }
  )

  (self: super:
    { rubydatalakegem = self.stdenv.mkDerivation
        { name = "rubydatalakegem";
          src = ../clients/RubyDatalake;
          buildPhase  =
            ''
              gem build datalake.gemspec
            '';
          installPhase =
            ''
              mkdir -p $out
              cp datalake-*.gem $out
            '';
          buildInputs = [ self.ruby ];
        };
    }
  )

  (self: super:
    { rubydatalake = super.bundlerEnv
        { name = "rubydatalake";
          ruby = super.ruby;
          gemdir = ../clients/RubyDatalake;
        };
    }
  )

  (self: super:
    { rubydatalake-tests =
        with (super.callPackage ./pfizer/datalake/environment.nix
          { inherit (self.haskellPackages) datalake-server; });
        let
          path = self.lib.makeBinPath
            [ self.ruby self.gcc ];
          runRubyTests = self.writeScript "run-ruby-tests"
            ''
              #!${self.stdenv.shell}
              source $stdenv/setup
              set -euo pipefail
              export PATH=${path}:$PATH
              export DATALAKE_HOST=localhost
              export DATALAKE_PORT=22089
              export RUBY_TEST_DIR=${../clients/RubyDatalake/test-cases}
              # TODO:
              #   1. Copy all the gems generated by "rubydatalake"
              #   2. Run this within withPG and withDL
              gem install --force --local \
                ${super.rubydatalakegem}/* \
                ${super.rubydatalake}/lib/ruby/gems/2.4.0/cache/*
              ruby ${../clients/RubyDatalake/test.rb}

              touch $out
            '';
          in self.runCommand "run-rubydatalake-tests" {}
                ''
                  ${withDatalakeServer {} runRubyTests}
                '';
    }
  )

  # jsaddle checks involve lots of dependencies so disable them
  (self: super:
    { haskellPackages =
        super.haskellPackages.extend
          (haskellSelf: haskellSuper:
            { jsaddle-warp =
              super.haskell.lib.dontCheck haskellSuper.jsaddle-warp;
            }
          );
    }
  )

  (self: super:
    { rPackages =
        super.rPackages.override
          {
            overrides =
              {
                rdatalake = import ../clients/RDatalake/default.nix
                  { inherit (self) callPackage rPackages;
                    nixpkgsSrc = self.path;
                  };
              };
          };
    }
  )

  # Helper bundle with all the datalake packages
  (self: super:
    { pydatalakeTarGz = self.stdenv.mkDerivation
        { name = "pydatalake-tar-gz";
          src = self.lib.cleanSource ../clients/PyDatalake;
          buildInputs = [ (super.python.withPackages (ps: [ps.setuptools])) ];
          phases = [ "unpackPhase" "installPhase" ] ;
          installPhase =
            ''
              touch -t "201108231405.14" * **/*
              python setup.py sdist --formats=zip,gztar --dist-dir=$out
            '';
        };
      }
  )

  (self: super:
    {
      python = super.python.override {
        packageOverrides = selfPython: superPython:
          {
            pydatalake = super.python.pkgs.buildPythonPackage rec
              { pname = "pydatalake";
                version = "4.0.0";
                src = "${super.pydatalakeTarGz}/PyDatalake-${version}.tar.gz";
                propagatedBuildInputs =
                  [ superPython.psycopg2
                    superPython.pyyaml
                    superPython.pandas
                    superPython.requests
                    superPython.sqlalchemy
                  ];
              };
          };
      };
    }
  )

  # Helper bundle with all the datalake packages
  (self: super:
    { datalakePackages = haskellPackages:
        super.lib.attrsets.filterAttrs
          (k: _: self.lib.strings.hasPrefix "datalake-" k)
          haskellPackages;
    }
  )

  (self: super:
    { datalake-tests = super.callPackage ./pfizer/datalake/test.nix {}; }
  )

  (self: super:
    { libredirect = super.callPackage ./libredirect {} ; }
  )

  (self: super: 
    { datalakeDocker = super.callPackage ../docker/docker.nix {datalake-server=super.haskellPackages.datalake-server;}; }
  )
]
