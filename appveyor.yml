version: "{build}"

init:
  # Prints RDP login details
  - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))

build:
  verbosity: normal

environment:
  global:
    STACK_ROOT: "c:\\sr"

cache:
- C:\sr -> stack.yaml                            # The stack root dir.
- C:\Users\appveyor\AppData\Local\Programs\stack\x86_64-windows

deploy: off

install:
  - ps: |
      bash -c 'curl -Lso stack.tar.gz -L --insecure https://github.com/commercialhaskell/stack/releases/download/v1.3.0/stack-1.3.0-windows-x86_64.tar.gz'
      tar -xvzf stack.tar.gz
      mkdir C:\stack
      mv stack-1.3.0-windows-x86_64\stack.exe C:\stack

build_script:
  # Add stack to the PATH
  - set PATH=C:\stack;%PATH%

  # Add the PostgreSQL folder to the path so that the DLLs can be found during
  # link
  - set PATH=C:\Progra~1\PostgreSQL\9.5\bin;%PATH%

  # In projects with lots of dependencies (like this one) stack is likely to fail
  # (potentially due to concurrent writes). See this issue:
  # https://github.com/commercialhaskell/stack/issues/2617
  # For now, we just retry a few times
  - for /l %%x in (1,1,10) do stack --no-terminal setup > nul || true
  - stack --no-terminal setup > nul
  - for /l %%x in (1,1,10) do stack --no-terminal install --test ingest datalake-cmdline > nul || true
  - stack --no-terminal install --test ingest datalake-cmdline

  # Bundle the datalake executable and the DLLs it depends on.  Windows will
  # look in the executable's directory for DLLs so we do not need to do
  # anything special (like we do for other OSs by setting (DY)LD_LIBRARY_PATH).
after_build:
  - ci\mk_datalake_bundle.cmd "datalake-win-x64"
  - appveyor PushArtifact %DATALAKE_ZIP%
