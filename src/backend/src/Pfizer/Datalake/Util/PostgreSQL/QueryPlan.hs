-- Copyright 2020 Pfizer Inc.

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveAnyClass #-}
-- | PostgreSQL query plans
--
-- Intended for qualified import
--
-- > import qualified Pfizer.Datalake.Util.PostgreSQL.QueryPlan as QueryPlan
module Pfizer.Datalake.Util.PostgreSQL.QueryPlan (
    -- * Query plans
    Plan_(..)
  , Plan
  , PlanTop
  , PlanCosts(..)
  , ParentRel(..)
  , PlanName
  , NodeType(..)
  , AggregateStrategy(..)
  , SetOpStrategy(..)
  , ModifyTableOp(..)
  , Relation(..)
  , Function(..)
  , CTEName
  , IndexName
  , JoinType(..)
  , SetOpCommand(..)
    -- * Functions
  , getQueryPlan
  , Summary(..)
  , summary
  ) where

import Control.Monad
import Control.Monad.Except
import Database.PostgreSQL.Simple (Query, Only(..))
import Data.Aeson
import Data.Aeson.Types
import Data.Monoid
import Data.List (nub)
import Data.Text (Text)
import GHC.Generics (Generic)
import Text.Show.Pretty
import qualified Data.Text        as Text
import qualified Text.PrettyPrint as PP

import Pfizer.Datalake.Interface (Pretty(..))
import Pfizer.Datalake.Util.PostgreSQL.Transaction

{-------------------------------------------------------------------------------
  Query plans

  EXPLAIN is documented in

  * https://www.postgresql.org/docs/9.4/static/sql-explain.html
  * https://www.postgresql.org/docs/9.4/static/using-explain.html

  However, there doesn't appear to be a specification of the JSON output
  (or any other kind of output for that matter). The output of explain is
  generated by @ExplainNode@ in @src/backend/commands/explain.c@ in the
  PostgreSQL source code.

  TODO: The following parts of the query plan are currently not parsed:

  * Aliases
  * Results from ANALYSE
  * Buffer usage
  * Scan direction
  * Plan target list (these are lists of columns output in verbose mode;
    see <http://blog.2ndquadrant.com/postgresql-guts-resjunk/>)
  * Instrumentation: metrics like
    "Rows Removed by Filter"
    "Rows Removed by Index Recheck"
  * Additional information about how indices are used:
    "Filter"
    "Function Call" (the exact call; we do record the function name)
    "Hash Cond"
    "Index Cond"
    "Join Filter"
    "Merge Cond"
    "One-Time Filter"
    "Order By"
    "Recheck Cond"
    "TID Cond"
-------------------------------------------------------------------------------}

-- | A node in a PostgreSQL query plan
data Plan_ a = Plan {
      -- | Plan type
      planNodeType :: NodeType

      -- | Relationship of this plan to its parent
    , planParentRel :: a

      -- | Plan children
    , planChildren :: [Plan]

      -- | Plan costs
      --
      -- NOTE: We assume that these costs are always present. This is not
      -- necessarily the case in general (depends on the EXPLAIN statement
      -- used), but it /is/ the case for us.
    , planCosts :: PlanCosts
    }
  deriving (Show, Eq, Generic, PrettyVal)

data Top = Top
  deriving (Show, Eq, Generic, PrettyVal)

type Plan    = Plan_ ParentRel
type PlanTop = Plan_ Top

data PlanCosts = PlanCosts {
      costStartup :: Float
    , costTotal   :: Float
    , costRows    :: Integer
    , costWidth   :: Integer
    }
  deriving (Show, Eq, Generic, PrettyVal)

data ParentRel =
    Outer
  | Inner
  | Subquery
  | Member
  | InitPlan PlanName
  | SubPlan PlanName
  deriving (Show, Eq, Generic, PrettyVal)

type PlanName = String
type IndexName = String

data NodeType =
    Unknown String
  | Aggregate AggregateStrategy
  | Append
  | BitmapAnd
  | BitmapHeapScan Relation
  | BitmapIndexScan IndexName
  | BitmapOr
  | CTEScan CTEName
  | ForeignScan Relation
  | FunctionScan (Maybe Function) -- ^ Function might be optimized away
  | Group
  | Hash
  | HashJoin JoinType
  | IndexOnlyScan IndexName Relation
  | IndexScan IndexName Relation
  | Limit
  | LockRows
  | Materialize
  | MergeAppend
  | MergeJoin JoinType
  | ModifyTable ModifyTableOp Relation
  | NestedLoop JoinType
  | RecursiveUnion
  | Result
  | SeqScan Relation
  | SetOp SetOpStrategy SetOpCommand
  | Sort
  | SubqueryScan
  | TidScan Relation
  | Unique
  | ValuesScan
  | WindowAgg
  | WorkTableScan CTEName
  deriving (Show, Eq, Generic, PrettyVal)

data AggregateStrategy =
    AggregatePlain
  | AggregateSorted
  | AggregateHashed
  | AggregateUnknown String
  deriving (Show, Eq, Generic, PrettyVal)

data SetOpStrategy =
    SetOpSorted
  | SetOpHashed
  | SetOpUnknown String
  deriving (Show, Eq, Generic, PrettyVal)

data ModifyTableOp =
    ModifyTableInsert
  | ModifyTableUpdate
  | ModifyTableDelete
  deriving (Show, Eq, Generic, PrettyVal)

-- | Table in the database
data Relation = Relation {
      relName   :: String
    , relSchema :: String
    }
  deriving (Show, Eq, Generic, PrettyVal)

-- | Function in the database
--
-- These occur in plans for queries such as
--
-- > SELECT * FROM some_function
--
-- See <http://dba.stackexchange.com/questions/58358/how-to-get-query-runtime-in-pl-pgsql-to-be-as-fast-as-console-query-runtime>
-- for an example.
data Function = Function {
       funName   :: String
     , funSchema :: String
     }
   deriving (Show, Eq, Generic, PrettyVal)

-- | Common table expression
--
-- These occur in plans for queries such as
--
-- > WITH bar AS (SELECT * FROM foo) SELECT * FROM bar
--
-- which yields a plan like
--
-- > CTE Scan on bar  (cost=22.30..46.90 rows=1230 width=36)
-- >   CTE bar
-- >     ->  Seq Scan on foo  (cost=0.00..22.30 rows=1230 width=36)
--
-- See <http://blog.2ndquadrant.com/postgresql-ctes-are-optimization-fences/>
-- for some further info.
type CTEName = String

data JoinType =
    JoinInner
  | JoinLeft
  | JoinFull
  | JoinRight
  | JoinSemi
  | JoinAnti
  | JoinUnknown String
  deriving (Show, Eq, Generic, PrettyVal)

-- | Set operation
--
-- This occurs in plans for queries such as
--
-- > (SELECT * FROM foo) INTERSECT (SELECT * FROM foo)
--
-- which yields a plan like
--
-- > HashSetOp Intersect
-- >   ->  Append
-- >         ->  Subquery Scan on "*SELECT* 1"
-- >               ->  Seq Scan on foo
-- >         ->  Subquery Scan on "*SELECT* 2"
-- >               ->  Seq Scan on foo foo_1
data SetOpCommand =
    SetOpCmdIntersect
  | SetOpCmdIntersectAll
  | SetOpCmdExcept
  | SetOpCmdExceptAll
  | SetOpCmdUnknown String
  deriving (Show, Eq, Generic, PrettyVal)

{-------------------------------------------------------------------------------
  Retrieve a plan
-------------------------------------------------------------------------------}

getQueryPlan :: MonadIO m => Query -> Transaction m (Either String [PlanTop])
getQueryPlan q = do
    -- execute_ $ "SET enable_seqscan = OFF" -- (useful during debugging)
    [Only v] <- query_ $ "EXPLAIN (FORMAT JSON, VERBOSE) " <> q
    return $ parseEither parseJSON v

{-------------------------------------------------------------------------------
  Query plan summary
-------------------------------------------------------------------------------}

-- | Summary of a query plan
data Summary = Summary {
      summaryReads  :: [Relation]
    , summaryWrites :: [Relation]
    }
  deriving (Show, Eq, Generic, PrettyVal)

instance Monoid Summary where
  mempty        = Summary {
                      summaryReads  = []
                    , summaryWrites = []
                    }
  a `mappend` b = Summary {
                      summaryReads  = append summaryReads
                    , summaryWrites = append summaryWrites
                    }
    where
      append :: Monoid a => (Summary -> a) -> a
      append f = f a `mappend` f b

readsOnly :: Relation -> Summary
readsOnly rel = mempty { summaryReads = [rel] }

writesOnly :: Relation -> Summary
writesOnly rel = mempty { summaryWrites = [rel] }

{-------------------------------------------------------------------------------
  Analyse query plan

  TODO: Right now summarizing a query plan returns 'Nothing' when it contains
  function calls. If we wanted to relax that we'd need to pass in an environment
  of known functions and the relations they access.
-------------------------------------------------------------------------------}

class Summarize a where
  -- | Summary the query plan
  --
  -- Returns 'Maybe' because there are some query plans we cannot analyze.
  summarize :: a -> Except String Summary

summary :: Summarize a => a -> Either String Summary
summary = runExcept . liftM cleanup . summarize
  where
    cleanup :: Summary -> Summary
    cleanup s = Summary {
        summaryReads  = nub $ summaryReads  s
      , summaryWrites = nub $ summaryWrites s
      }

instance Summarize a => Summarize [a] where
  summarize = liftM mconcat . mapM summarize

instance Summarize a => Summarize (Either String a) where
  summarize (Left  e) = throwError e
  summarize (Right a) = summarize a

instance Summarize NodeType where
  summarize (Unknown typ)       = throwError $ "Unknown node type " ++ show typ
  summarize (FunctionScan _fun) = throwError $ "Query plan contains functions"
  summarize (BitmapHeapScan      rel) = return $ readsOnly rel
  summarize (ForeignScan         rel) = return $ readsOnly rel
  summarize (IndexOnlyScan _name rel) = return $ readsOnly rel
  summarize (IndexScan     _name rel) = return $ readsOnly rel
  summarize (SeqScan             rel) = return $ readsOnly rel
  summarize (TidScan             rel) = return $ readsOnly rel
  summarize (ModifyTable _op     rel) = return $ writesOnly rel
  summarize (Aggregate _strat)        = return mempty
  summarize Append                    = return mempty
  summarize BitmapAnd                 = return mempty
  summarize (BitmapIndexScan _name)   = return mempty
  summarize BitmapOr                  = return mempty
  summarize (CTEScan _cte)            = return mempty
  summarize Group                     = return mempty
  summarize Hash                      = return mempty
  summarize (HashJoin _typ)           = return mempty
  summarize Limit                     = return mempty
  summarize LockRows                  = return mempty
  summarize Materialize               = return mempty
  summarize MergeAppend               = return mempty
  summarize (MergeJoin _typ)          = return mempty
  summarize (NestedLoop _typ)         = return mempty
  summarize RecursiveUnion            = return mempty
  summarize Result                    = return mempty
  summarize (SetOp _op _cmd)          = return mempty
  summarize Sort                      = return mempty
  summarize SubqueryScan              = return mempty
  summarize Unique                    = return mempty
  summarize ValuesScan                = return mempty
  summarize WindowAgg                 = return mempty
  summarize (WorkTableScan _cte)      = return mempty

instance Summarize (Plan_ a) where
  summarize Plan{..} = mappend <$> summarize planNodeType
                               <*> summarize planChildren

{-------------------------------------------------------------------------------
  Pretty printing
-------------------------------------------------------------------------------}

instance Pretty Summary where
  pretty Summary{..} = PP.vcat [
      "reads: "  <> PP.hcat (PP.punctuate ", " $ map pretty summaryReads)
    , "writes: " <> PP.hcat (PP.punctuate ", " $ map pretty summaryWrites)
    ]

instance Pretty Relation where
  pretty Relation{..} = pretty relSchema <> "." <> pretty relName

instance Pretty (Either String Summary) where
  pretty (Left  e) = pretty e
  pretty (Right s) = pretty s

{-------------------------------------------------------------------------------
  FromJSON instances
-------------------------------------------------------------------------------}

instance FromJSON AggregateStrategy where
  parseJSON = withText "AggregateStrategy" $ \case
    "Plain"  -> return AggregatePlain
    "Sorted" -> return AggregateSorted
    "Hashed" -> return AggregateHashed
    strategy -> return $ AggregateUnknown (Text.unpack strategy)

instance FromJSON SetOpStrategy where
  parseJSON = withText "SetOpStrategy" $ \case
    "Sorted" -> return SetOpSorted
    "Hashed" -> return SetOpHashed
    strategy -> return $ SetOpUnknown (Text.unpack strategy)

instance FromJSON ModifyTableOp where
  parseJSON = withText "ModifyTableOp" $ \case
    "Insert"  -> return ModifyTableInsert
    "Update"  -> return ModifyTableUpdate
    "Delete"  -> return ModifyTableDelete
    operation -> fail $ "Unknown ModifyTable operation " ++ show operation

instance FromJSON JoinType where
  parseJSON = withText "JoinType" $ \case
    "Inner" -> return JoinInner
    "Left"  -> return JoinLeft
    "Full"  -> return JoinFull
    "Right" -> return JoinRight
    "Semi"  -> return JoinSemi
    "Anti"  -> return JoinAnti
    typ     -> return $ JoinUnknown (Text.unpack typ)

instance FromJSON SetOpCommand where
  parseJSON = withText "SetOpCommand" $ \case
    "Intersect"     -> return SetOpCmdIntersect
    "Intersect All" -> return SetOpCmdIntersectAll
    "Except"        -> return SetOpCmdExcept
    "Except All"    -> return SetOpCmdExceptAll
    cmd             -> return $ SetOpCmdUnknown (Text.unpack cmd)

instance FromJSON PlanTop where
  parseJSON = withObject "PlanTop" $ \obj -> do
    plan <- join $ fromObject <$> obj .: "Plan"
    return $ plan { planParentRel = Top }

instance FromJSON Plan where
  parseJSON = withObject "Plan" $ \obj -> do
    plan <- fromObject obj
    rel  <- fromObject obj
    return $ plan { planParentRel = rel }

{-------------------------------------------------------------------------------
  FromObject instances
-------------------------------------------------------------------------------}

-- | The structure of the JSON is a little more " flat " than the structure
-- of our representation, with various parts of the plan all represented using
-- some combination of fields from a top-level JSON object. 'FromObject'
-- allows us define the " unflattening " a bit more conveniently.
class FromObject a where
  fromObject :: Object -> Parser a

instance FromObject NodeType where
  fromObject obj =
      join $ go <$> obj .: "Node Type"
    where
      go :: Text -> Parser NodeType
      go "Index Only Scan"   = IndexOnlyScan   <$> obj .: "Index Name"
                                               <*> fromObject obj
      go "Index Scan"        = IndexScan       <$> obj .: "Index Name"
                                               <*> fromObject obj
      go "ModifyTable"       = ModifyTable     <$> obj .: "Operation"
                                               <*> fromObject obj
      go "SetOp"             = SetOp           <$> obj .: "Strategy"
                                               <*> obj .: "Command"
      go "Aggregate"         = Aggregate       <$> obj .: "Strategy"
      go "Bitmap Index Scan" = BitmapIndexScan <$> obj .: "Index Name"
      go "CTE Scan"          = CTEScan         <$> obj .: "CTE Name"
      go "Hash Join"         = HashJoin        <$> obj .: "Join Type"
      go "Merge Join"        = MergeJoin       <$> obj .: "Join Type"
      go "Nested Loop"       = NestedLoop      <$> obj .: "Join Type"
      go "WorkTable Scan"    = WorkTableScan   <$> obj .: "CTE Name"
      go "Bitmap Heap Scan"  = BitmapHeapScan  <$> fromObject obj
      go "Foreign Scan"      = ForeignScan     <$> fromObject obj
      go "Function Scan"     = FunctionScan    <$> fromObject obj
      go "Seq Scan"          = SeqScan         <$> fromObject obj
      go "Tid Scan"          = TidScan         <$> fromObject obj
      go "Append"            = return Append
      go "BitmapAnd"         = return BitmapAnd
      go "BitmapOr"          = return BitmapOr
      go "Group"             = return Group
      go "Hash"              = return Hash
      go "Limit"             = return Limit
      go "LockRows"          = return LockRows
      go "Materialize"       = return Materialize
      go "Merge Append"      = return MergeAppend
      go "Recursive Union"   = return RecursiveUnion
      go "Result"            = return Result
      go "Sort"              = return Sort
      go "Subquery Scan"     = return SubqueryScan
      go "Unique"            = return Unique
      go "Values Scan"       = return ValuesScan
      go "WindowAgg"         = return WindowAgg
      go typ                 = return $ Unknown (Text.unpack typ)

instance FromObject ParentRel where
  fromObject obj =
      join $ go <$> obj .: "Parent Relationship"
    where
      go :: Text -> Parser ParentRel
      go "Outer"    = return Outer
      go "Inner"    = return Inner
      go "Subquery" = return Subquery
      go "Member"   = return Member
      go "InitPlan" = InitPlan <$> obj .: "Subplan Name"
      go "SubPlan"  = SubPlan  <$> obj .: "Subplan Name"
      go relation   = fail $ "Unknown ParentRel " ++ show relation

instance FromObject PlanCosts where
  fromObject obj = do
    costStartup <- obj .: "Startup Cost"
    costTotal   <- obj .: "Total Cost"
    costRows    <- obj .: "Plan Rows"
    costWidth   <- obj .: "Plan Width"
    return PlanCosts{..}

-- | The 'FromObject' instance for 'Plan_' sets everything except
-- 'planParentRel'.
instance FromObject (Plan_ a) where
  fromObject obj = do
    planNodeType <- fromObject obj
    planCosts    <- fromObject obj
    planChildren <- obj .:? "Plans" .!= []
    return $ Plan{planParentRel = undefined, ..}

instance FromObject Relation where
  fromObject obj = do
    relName   <- obj .: "Relation Name"
    relSchema <- obj .: "Schema"
    return Relation{..}

instance FromObject (Maybe Function) where
  fromObject obj = do
    mFunName <- obj .:? "Function Name"
    case mFunName of
      Nothing      -> return Nothing
      Just funName -> do
        funSchema <- obj .: "Schema"
        return $ Just Function{..}
